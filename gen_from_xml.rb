#!/usr/bin/env ruby -w

require 'nokogiri'
require 'open-uri'
require 'fiddle'

KHRONOS_GL_XML = 'https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/gl.xml'

if !File.exist?('gl.xml')
  puts "gl.xml doesn't exist: downloading <#{KHRONOS_GL_XML}>..."
  curl_pid = Process.spawn("curl --output 'gl.xml' '#{KHRONOS_GL_XML}'")
  Process.wait(curl_pid)
  if !$?.exited? || !$?.success?
    puts "Download failed. Try again."
    exit 1
  end
  puts "Download complete."
end

# name => String
# value => String
# alias => nil | String
GLEnum = Struct.new(:name, :value, :alias)

# name => String
# type => String
# core => String (substring of type or nil)
GLParam = Struct.new(:name, :type, :core)

# name       => String
# type       => GLParam (name -> nil)
# parameters => [GLParam]
GLCommand = Struct.new(:name, :type, :parameters)

# command_suffix => String
# enum_suffix    => String
GLVendor = Struct.new(:command_suffix, :enum_suffix)

# Set to false to generate bindings for non-core profile functions/enums
GEN_GL3_AND_UP = true


SELECT_ENUMS_XPATH    = 'registry/enums/enum[@name and @value and (not(@api) or not(starts-with(@api, "gles")))]'
SELECT_COMMANDS_XPATH = 'registry/commands/command'
SELECT_TYPEDEFS_XPATH = 'registry/types/type[(not(@api) or not(starts-with(@api, "gles"))) and (not(@name) or not(starts-with(@name, "khr")))]'
SELECT_TYPE_XPATH     = 'ptype/text()|text()'

def typename(from)
  from.type.strip.gsub(/\s+(?=\*)/, '').to_sym
end

def get_type(from)
  from.inner_text.chomp(from.at('name').text)
end

def get_enums(document)
  enums = {}
  document.xpath(SELECT_ENUMS_XPATH).each {
    |gl_enum|

    enum_name = gl_enum['name']
    enum_value = gl_enum['value']
    enum_alias = gl_enum['alias']

    enums[enum_name] = GLEnum.new(enum_name, enum_value, enum_alias)
  }
  enums
end

def get_commands(document)
  commands = {}
  document.xpath(SELECT_COMMANDS_XPATH).each {
    |gl_command|

    proto = gl_command.at('proto')
    name = proto.at('name').text
    params = []
    gl_command.xpath('param').each {
      |gl_param|
      ptype = gl_param.at('ptype')
      full_type = get_type(gl_param)
      params << GLParam.new(gl_param.at('name').text, full_type, ptype ? ptype.text : full_type.strip)
    }

    ptype = proto.at('ptype')
    full_return_type = get_type(proto)
    return_type = GLParam.new(nil, full_return_type, ptype ? ptype.text : full_return_type.strip)

    commands[name] = GLCommand.new(name, return_type, params)
  }
  commands
end

def generate_binding_impl(document)
  filtered_commands = {}
  filtered_enums = {}

  begin
    gl_commands = get_commands(document)
    gl_enums = get_enums(document)

    pull_feature = proc { |feature|
      feature_name = feature['name']
      feature_kind = feature.name

      case feature_kind
      when 'enum' then filtered_enums[feature_name] = gl_enums[feature_name]
      when 'command' then filtered_commands[feature_name] = gl_commands[feature_name]
      else raise "Unrecognized feature kind"
      end
    }

    drop_feature = proc { |feature|
      feature_name = feature['name']
      feature_kind = feature.name

      case feature_kind
      when 'enum' then filtered_enums.delete(feature_name)
      when 'command' then filtered_commands.delete(feature_name)
      else raise "Unrecognized feature kind"
      end
    }

    extensions = document.xpath("registry/extensions/extension")
    core_exts = extensions.select { |ext| ext['supported'] =~ /\bglcore\b/ }
    core_exts.each { |ext|
      ext.xpath('extension/require/*[(self::command|self::enum)]').each(&pull_feature)
    }

    features = document.xpath('registry/feature')
    gl_features = features.select { |feature| feature['api'] =~ /\bgl\b/ }
    gl_features.each { |feature|
      feature.xpath('require/*[(self::command|self::enum)]').each(&pull_feature)
      if GEN_GL3_AND_UP
        feature.xpath('remove[@profile="core"]/*[(self::command|self::enum)]').each(&drop_feature)
      end
    }
  end

  enum_name_length  = filtered_enums.map { |k, enum| enum.name.length }.max
  prefix            = document.url.chomp(File.extname(document.url))

  File.open("lib/opengl-core/#{prefix}-enums.rb", 'w') {
    |io|

    io.puts <<-EOS
#  This file is part of the opengl-core project.
#  <https://github.com/nilium/ruby-opengl>
#
#  -----------------------------------------------------------------------------
#
#  gl-enums.rb
#    File containing GL enumerators.
#    This file is generated by gen_from_xml.rb, do not modify it.


module GL
EOS

    filtered_enums.select { |name, enum| enum.alias.nil? }.each {
      |name, enum|
      io.puts "  # @api raw\n  #{name.ljust(enum_name_length)} = #{enum.value}"
    }

    filtered_enums.select { |name, enum| !enum.alias.nil? }.each {
      |name, enum|
      if !filtered_enums[enum.alias]
        prefixed_alias = "GL_#{enum.alias}"
        if filtered_enums[prefixed_alias]
          enum.alias = prefixed_alias
        else
          next if enum.value.nil?
          enum.alias = enum.value
        end
      end


      io.puts "  # @api raw\n  #{name.ljust(enum_name_length)} = #{enum.alias}"
    }

    io.puts 'end # module GL'
  }

  File.open("lib/opengl-core/#{prefix}-commands.rb", 'w') {
    |io|

    io.puts <<-EOS
#  This file is part of the opengl-core project.
#  <https://github.com/nilium/ruby-opengl>
#
#  -----------------------------------------------------------------------------
#
#  gl-commands.rb
#    File containing GL commands.
#    This file is generated by gen_from_xml.rb, do not modify it.


require 'opengl-core/gl-sym'


module GL

#{
  filtered_commands.map {
    |name, cmd|
    # Put a _ on the end of each argument to avoid conflicts with reserved words
    param_string = cmd.parameters.map { |p| "#{p.name}_" }.join(', ')

    <<-EOS_INNER
  GLSym::GL_COMMAND_TYPES[:#{name}] = {
    parameter_types: [#{cmd.parameters.map { |p| typename(p).inspect }.join(', ') }],
    return_type:     #{ typename(cmd.type).inspect }
  }

  # @api raw
  def #{name}__(#{param_string})
    GLSym.load_sym(:#{name}).call(#{param_string})
  end

  alias_method :'#{name}', :'#{name}__'

    EOS_INNER
  }.join('')
}end # module GL
EOS
  }
end



# Read gl.xml

document_paths = [ 'gl.xml' ]

document_paths.each {
  |path|
  document = Nokogiri.XML(File.open(path, 'r'), path)
  generate_binding_impl(document)
}
